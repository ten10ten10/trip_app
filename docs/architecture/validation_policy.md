# Validator導入方針レポート

## 1. はじめに

本レポートは、アプリケーションにおけるバリデーション（入力値検証）の実装方針を定めるものである。一貫した設計ルールを適用することで、コードの品質、保守性、拡張性を向上させることを目的とする。

## 2. 基本方針

バリデーションの責務を以下の2種類に明確に分離し、それぞれを担当するレイヤー（層）を定める。

1.  **形式チェック (Syntactic Validation):** リクエストがAPIの要求する基本的な形式を満たしているかの検証。
2.  **ビジネスルールチェック (Semantic Validation):** データがビジネス上のルールや制約に適合しているかの検証。

## 3. 各レイヤーの責務と実装

### 3.1. Handler層 Validator

*   **責務:** **形式チェック**を担当する。HTTPリクエストが後続の処理に進むための、最低限の前提条件を満たしていることを保証する。
    *   必須フィールドの存在確認 (`required`)
    *   データ型、フォーマット（メールアドレス形式など）、文字数制限の検証

*   **実装:**
    *   **配置場所:** `internal/handler/` パッケージ直下に、`xxx_validator.go`という命名でファイルを作成する。
    *   **依存関係:** ハンドラは、同じ`handler`パッケージ内にある自身のバリデータに依存する。
    *   **エラー処理:** バリデーションエラーが発生した場合、ハンドラは`400 Bad Request`などのHTTPステータスコードと共に、具体的なエラー内容をクライアントに返却する。

    ```go
    // 例: internal/handler/schedule_validator.go
    package handler

    type ScheduleHandlerValidator interface {
        ValidateAddSchedule(req api.NewSchedule) error
    }
    // ...実装
    ```

### 3.2. Usecase層 Validator

*   **責務:** **ビジネスルールチェック**を担当する。データがビジネス的に妥当であるかを検証する。この検証には、データベースへのアクセスを伴う場合もある。
    *   フィールド間の関係性の検証（例: 終了日時は開始日時より後であること）
    *   データの整合性チェック（例: メールアドレスの重複確認）
    *   関連データの存在チェック（例: 指定されたユーザーIDが存在するか）

*   **実装:**
    *   **配置場所:** `internal/usecase/` パッケージ直下に、`xxx_validator.go`という命名でファイルを作成する。
    *   **依存関係:** ユースケースは、同じ`usecase`パッケージ内にある自身のバリデータに依存する。
    *   **エラー処理:** バリデーションエラーが発生した場合、ユースケースは`ErrValidation`のようなドメインエラーを返却する。具体的なHTTPステータスコードには関与しない。

    ```go
    // 例: internal/usecase/schedule_validator.go
    package usecase

    type ScheduleUsecaseValidator interface {
        ValidateCreateSchedule(startDateTime, endDateTime time.Time) error
    }
    // ...実装
    ```

## 4. 議論された他のアプローチ

今回の結論に至るまでに、以下の代替案も検討した。

*   **ミドルウェア案:** 形式チェックを`middleware`層で行う案。ハンドラが純化するメリットがあったが、どのルートにどの検証が適用されているかの追跡が煩雑になる可能性を考慮し、今回は採用を見送った。
*   **中央集権Validator案:** `internal/validator`パッケージに全てのバリデータを集約する案。当初はこの形で進めたが、レイヤーごとの責務をより明確に分離するため、現在の分散配置方式に方針転換した。
